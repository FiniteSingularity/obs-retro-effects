uniform float4x4 ViewProj;
uniform texture2d image;
uniform float2 uv_size;
uniform float progress;
uniform float2 vert_range;
uniform float2 horiz_range;
uniform float2 fade_range;

sampler_state textureSampler{
    Filter = Linear;
    AddressU = Border;
    AddressV = Border;
    MinLOD = 0;
    MaxLOD = 0;
    BorderColor = FF000000;
};

struct VertData
{
	float4 pos : POSITION;
	float2 uv : TEXCOORD0;
};

VertData mainTransform(VertData v_in)
{
	v_in.pos = mul(float4(v_in.pos.xyz, 1.0), ViewProj);
	return v_in;
}

float4 mainImage(VertData v_in) : TARGET
{
	float2 d = v_in.uv - float2(0.5, 0.5);
	float2 progress_norm = float2(saturate((progress - horiz_range.x) / (horiz_range.y - horiz_range.x)), saturate((progress - vert_range.x) / (vert_range.y - vert_range.x)));
	float progress_fade = saturate((progress - fade_range.x) / (fade_range.y - fade_range.x));
	d *= (1.0 + 100.0 * progress_norm);
	float2 uv = float2(0.5, 0.5) + d;
	float2 ap = step(abs(d), float2(0.5, 0.5)); // Thanks to twitch viewer
	bool inside = ap.x * ap.y > 0.;             // FuleSnabel
	float4 color = image.Sample(textureSampler, uv);
	color.rgb += max(progress_norm.x, progress_norm.y);
	return inside ? color * (1.0 - progress_fade) + (progress_fade) * float4(0.0, 0.0, 0.0, 1.0) : float4(0.0, 0.0, 0.0, 1.0);
}

technique Draw
{
	pass
	{
		vertex_shader = mainTransform(v_in);
		pixel_shader = mainImage(v_in);
	}
}
